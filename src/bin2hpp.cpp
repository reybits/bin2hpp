/**********************************************\
*
*  Binary to C-array converter
*  Andrey A. Ugolnik (c) 2000, 2023, 2024
*  andrey@ugolnik.info
*
*  Based on BIN2HPP.CPP
*  by Shabarshin A. A. 02.09.2000, 10.03.2003
*
\**********************************************/

#include "file.h"
#include "file_cache.h"

#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>

namespace
{
    void TrimExt(std::string& str)
    {
        auto pos = str.find_last_of(".");
        if (pos != std::string::npos)
        {
            str.resize(pos);
        }
    }

    std::string MakeOutputPath(const char* desired, const std::string& input)
    {
        std::string output = desired != nullptr
            ? desired
            : input;

        TrimExt(output);
        output += ".h";

        return output;
    }

    std::string MakeVariableName(const char* desired, const std::string& input)
    {
        std::string variable = desired != nullptr
            ? desired
            : input;

        TrimExt(variable);

        for (auto& c : variable)
        {
            if (c >= 'A' && c <= 'Z')
            {
                c += 32;
            }
            if (!(c >= 'a' && c <= 'z') && !(c >= '0' && c <= '9'))
            {
                c = '_';
            }
        }

        return variable;
    }

} // namespace

int main(int argc, char* argv[])
{
    if (argc < 2)
    {
        printf("Binary to C-array converter.\n");
        printf("Andrey A. Ugolnik, May 18, 2024.\n");
        printf("Based on BIN2HPP.CPP by Shabarshin A. A.\n");
        printf("\n");
        printf("%s binary_file [options] input_file [output_file]\n", argv[0]);
        printf("     Options:\n");
        printf("      -s N      - bytes to read (default: whole input_file).\n");
        printf("      -w NH     - bytes per line (default: 8 bytes).\n");
        printf("      --static  - adds static modificator.\n");
        printf("\n");
        return 1;
    }

    auto addStatic = false;
    size_t bytesToRead = 0;
    size_t bytesPerRow = 8;
    const char* inputPath = nullptr;
    const char* outputName = nullptr;

    for (int i = 1; i < argc; i++)
    {
        if (strncmp(argv[i], "-w", 2) == 0)
        {
            bytesPerRow = (size_t)atoi(argv[++i]);
        }
        else if (strncmp(argv[i], "-s", 2) == 0)
        {
            bytesToRead = strtoul(argv[++i], nullptr, 10);
        }
        else if (strncmp(argv[i], "--static", 8) == 0)
        {
            addStatic = true;
        }
        else
        {
            if (inputPath == nullptr)
            {
                inputPath = argv[i];
            }
            else if (outputName == nullptr)
            {
                outputName = argv[i];
            }
        }
    }

    if (inputPath == nullptr)
    {
        printf("No input name provided.\n");
        return 1;
    }

    cFile in;
    if (in.open(inputPath) == false)
    {
        printf("Can't open input file '%s'.\n", inputPath);
        return 2;
    }

    if (bytesToRead == 0)
    {
        bytesToRead = in.getSize();
    }

    auto outputPath = MakeOutputPath(outputName, inputPath);
    auto variableName = MakeVariableName(outputName, inputPath);

    cFile out;
    if (out.open(outputPath.c_str(), "wt") == false)
    {
        printf("Can't open output file '%s'.\n", outputPath.c_str());
        return 3;
    }

    auto staticPrefix = addStatic
        ? "static "
        : "";
    auto var = variableName.c_str();

    auto o = static_cast<FILE*>(out.getHandle());

    std::fprintf(o, "/* Generated by bin2hpp */\n");
    std::fprintf(o, "/* Binary to C-array converter */\n");
    std::fprintf(o, "/* https://bitbucket.org/andreyu/bin2hpp */\n\n");
    std::fprintf(o, "%sconst size_t %s_size = %lu;\n", staticPrefix, var, bytesToRead);
    std::fprintf(o, "%sconst unsigned char %s[%lu] =\n", staticPrefix, var, bytesToRead);
    std::fprintf(o, "{");

    uint8_t buffer[1024];
    const auto bufferSize = sizeof(buffer) / sizeof(buffer[0]);

    cFileCache cache(out, 1024 * 10);
    for (size_t i = 0; i < bytesToRead; i++)
    {
        auto idx = i % bufferSize;
        if (idx == 0)
        {
            auto readed = in.read(buffer, bufferSize);
            if (readed != bufferSize)
            {
                // last chunk
            }
        }

        if (i % bytesPerRow == 0)
        {
            auto count = std::snprintf(cache.buffer(), cache.remain(), "\n    0x%2.2X,", buffer[idx]);
            cache.append(count);
            // std::fprintf(o, "\n    ");
        }
        else
        {
            auto count = std::snprintf(cache.buffer(), cache.remain(), "0x%2.2X,", buffer[idx]);
            cache.append(count);
        }

        if (cache.remain() < 20)
        {
            cache.flush();
        }
    }

    cache.flush();

    const char footer[] = "\n};\n";
    out.write((void*)footer, sizeof(footer) - 1);

    return 0;
}
